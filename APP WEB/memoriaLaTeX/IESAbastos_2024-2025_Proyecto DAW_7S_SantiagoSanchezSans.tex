\documentclass[a4paper,12pt]{report}
\setcounter{secnumdepth}{3} % Ensure subsubsections are numbered
\setcounter{tocdepth}{3} %per a que surtin subseccions en index (3.4.2.1 apareix amb depth 3)
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}  % Cambia el idioma a español
\usepackage{geometry}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{hyperref} % Paquete para enlaces clicables
\usepackage{placeins} % per a les float barrier, que no es moguin les imatges.
\usepackage{titlesec}  % Paquete para personalizar títulos
\usepackage{float}  %pquete para que las figuras no se de splacen
\usepackage{listings} %para poner entronos de codigo 
%\usepackage{svg}
\titleformat{\chapter}[hang] % Configuración para reducir el espacio superior de los capítulos
{\normalfont\huge\bfseries} % Formato de la fuente y tamaño del capítulo
{Capítulo \thechapter}{0pt}{\huge}  % Sin espacio entre "Capítulo X" y el título
\titlespacing*{\chapter}{0pt}{-20pt}{20pt} % Ajustes de espacio antes, después, y debajo del título




\usepackage{xcolor} % Para definir colores personalizados

% Configuración del estilo para Git
\lstset{
	language=bash,                   % Usa Bash para sintaxis similar a Git
	basicstyle=\ttfamily\small,      % Texto monoespaciado y pequeño
	keywordstyle=\bfseries,          % Palabras clave en negrita
	commentstyle=\color{gray},       % Comentarios en gris
	morekeywords={git, clone, add, branch, checkout, commit, push}, % Palabras clave de Git
	showstringspaces=false           % No mostrar espacios en cadenas de texto
}



% Configuración de márgenes
\geometry{left=3cm, right=3cm, top=2.5cm, bottom=2.5cm}

% Configuración de espacios
\setstretch{1.15}


% Configuración de formato de títulos
\titleformat{\chapter}[display]
{\normalfont\bfseries\Huge}
{}{0pt}{\Huge}

\hypersetup{
	colorlinks=true,        % Colorear enlaces
	linkcolor=blue,         % Color de los enlaces internos
	urlcolor=blue,          % Color de los enlaces externos (URLs)
	pdftitle={Memoria Proyecto}, % Título del PDF
	pdfauthor={Jorge Muñoz Carrión, Santiago Sánchez Sans} % Autor
}

\begin{document}
	
	

	
	
	
	% Portada
	\begin{titlepage}
		\begin{center}

			
			\vspace*{5cm} 

			\LARGE{Creación de un dashboard para usuarios del ticket digital de Mercadona con consultas visuales a la evolución de productos habitualmente adquiridos, costes de compras por intervalos temporales y gastos por áreas de producto}
			
			\vfill
			
		\begin{flushright}
			\large{\textbf{Santiago Sánchez Sans}}
			
			\large{\textit{Ciclo formativo en desarrollo de aplicaciones web}}
			
			\large{Memoria del Proyecto de DAW}
			
			\large{IES Abastos. Curso 2024/25. Grupo 7X. XX de Junio de 2025}
			
			\large{Tutor Individual: Carlos Furones}
		\end{flushright}

			
			
			% Fecha
			
			
		\end{center}
	\end{titlepage}
	
	% Índice
	\tableofcontents
	\newpage
	
	
	
	
	
	
	
	
	% Per a conseguir que els espais apliquin solsament a les seccions no a l'index
	\begingroup
	\setlength{\parskip}{.7em}
	
	
	% Capítulos y secciones
	\chapter{Identificación de objetivos}

		\section{¿Qué es el ticket digital de Mercadona?}
		
		Mercadona implementa un sistema de tickets digitales que vinculan la tarjeta de débito a un correo electrónico. Cualquier usuario del supermercado que quiera utilizar el ticket digital solamente deberá facilitar estos dos datos y el supermercado le enviará por correo electrónico los tickets de las posteriores compras hechas en cualquier establecimiento de Mercadona.
		
		Las ventajas para el usuario son evidentes: no se pierden los tickets de cara a devoluciones y el cliente del supermercado no debe esperar a la impresión del ticket.
		
		
		
		\section{Identificación de necesidades}
		\label{section:identificacionNecesidades}
		
		Los tickets de cada usuario se acumulan de forma recurrente en el correo electrónico y con un formato estructurado (los asuntos son predecibles e incluyen las fechas) y dentro de cada correo de un ticket digital se encuentra un PDF con el desglose de la compra (producto, unidades vendidas, establecimiento, etc).
		
		Esta información se acumula en el correo del usuario pero a pesar de ser una información estructurada su acceso para el usuario no es simple: no puede visualizar lo que ha gastado, ni el precio de los productos y de su evolución, ni los supermercados en los que ha comprado, ni las veces que lo ha hecho, etc.

		\section{Objetivos del proyecto} % OBLIGAT
		\label{section:objetivosProyecto}
		
		Este proyecto quiere responder a estas necesidades. Para ello se plantea la Creación de un dashboard o "cuadro de mando" front-end para que un usuario del ticket digital de Mercadona pueda visualizar la evolución de precios de los productos adquiridos, el coste promedio de sus compras por períodos temporales y sus distribuciones de gastos a partir de los tickets digitales guardados en una base de datos.
		
		
		Los \textbf{Objetivos principales} del proyecto son mostrar al usuario:

					
		\begin{itemize}
			\setlength{\itemsep}{-.5em}
			\item \textbf{Evolución de precios} (inflación) a lo largo del tiempo en los productos habitualmente comprados en el mismo establecimiento\footnote{La evolución de precios se mostrará solamente para un mismo centro de Mercadona, dado que distintos centros pueden cambiar los nombres de los productos (por ejemplo, en Cataluña…).}.
			\item \textbf{Evolución del gasto} total del usuario a lo largo del tiempo.
		\end{itemize}
		
		
		

		
		

		
		
		
		
		
		
		
		
		
		
			%IDENTIFICAR OBJECTIUS  %OBLIGAT
			%JUSTIFICAR OBJECTIUS   %OBLIGAT
			
			
	
		
	

		



		
	

		
	

		


		

		
		
		
		
	
	\chapter{Diseño del proyecto}  %OBLIGAT
	
		
				
		Para implementar los objetivos principales de los que hemos hablado en la sección \ref{section:objetivosProyecto} hemos proyectado una serie de requisitos funcionales de la aplicación.
		
		


		
		
		
		
		\section{Requisitos Funcionales}
		
			NOTA: Los requisitos aquí presentes se suman a los requisitos que se sobreentiende que tiene la aplicación de un proyecto final de grado superior y que esta aplicación, por supuesto, cumple: tener un front-end, un back-end con sistema de registro de usuarios y un login con buenas prácticas en materia de seguridad y una base de datos.
		
		
			\subsection{Requisitos de la aplicación}
			
		

			

			
		
			
			\textbf{REQUISITO A:} Mostrar evolución de los precios de los productos unitarios adquiridos con más frecuencia (visualizable en un gráfico donde en X tendremos el tiempo y en Y el precio en euros). Para los productos de precios muy variables (productos a granel, como frutas, etc.), se mostrará la evolución del precio por kg a lo largo del tiempo.
			
			\textbf{REQUISITO B:} Coste total de la cesta de la compra del usuario a lo largo de distintas ventanas temporales (por meses, períodos de 3, 6 meses y un año), independientemente del centro de Mercadona en el que se compre (todos juntos).
			
			\textbf{REQUISITO C:} Al lado de este mismo coste total mostrado en REQUISITO B, se incluirá un diagrama de queso (o de sectores) desglosando qué porcentaje del dinero se ha destinado a cada una de las siguientes categorías: verdura y hortalizas, frutas, huevos y lácteos, agua y bebidas, aceite y especias, carnes, pescado, hogar e higiene personal.Para ello, dado que no tenemos categorizados todos los productos de Mercadona ni podríamos hacerlo por falta de una lista exhaustiva y de tiempo, se usará un modelo predictivo con word embeddings (módulo Spacy) y cosine similarity (sklearn) para encontrar distancias pequeñas entre las descripciones de los tickets y las categorías, facilitando así la clasificación.
			
			
			
			\textbf{REQUISITO D:} Un botón ``Actualizar'' permitirá al usuario refrescar los datos desde el servidor cuando haya añadido nuevas compras. También podríamos permitir que los PDFs descargados en el servidor se almacenen en una carpeta local del usuario para que pueda verificar la extracción de los datos.
			
			\textbf{REQUISITO E:} Hacer un sistema front-end y back-end que permitan redirigir a los usuarios rápidamente a un registro de forma inteligente. Nos inspiraremos en el sistema de registro e iniciar sesión de NetFlix \textbf{(POSAR DIAGRAMA A L'ANEX SOBRE EL SISTEMA DEL NETFLIX I EL NOSTRE)}
			
			\subsection{Requisitos de los usuarios}
			
			El correo electrónico y la contraseña de la cuenta de Gmail de alguien que sea usuario del ticket digital de Mercadona y tenga decenas de tickets digitales por analizar, con compras estables y productos recurrentes.
			
			Nota: En la demo se proporcionarán ya muchos tickets digitales (tickets míos, que cederé para mostrar la utilidad de la aplicación). No será necesario recurrir a la extracción de datos de otro usuario de ticket digital. Se mostrarán un mínimo de tickets digitales en un mismo centro de Mercadona para poder evidenciar la evolución de precios y gastos.
			
		
		\section{Stack tecnológico}
	
		Hemos escogido un stack tecnológico que permite que seamos fieles a los requisitos funcionales que nos hemos marcado para la aplicación:
		
			 \subsection{Front-End: HTML, CSS y Javascript}
			 
			Se ha usado HTML, CSS y JavaScript. - Para la visualización de gráficos se usará una librerría javascript: https://www.chartjs.org/. Entre otras cosas se utilizará para hacer los gráficos de la evolución de precios por producto.
			
			Para el sistema de registro e iniciar sesión se ha hecho una réplica mediante desarrollo inverso de los procesos de registro e inicio sesión de netflix y se ha adaptado a este caso particular (puede verse en \ref{sec:EnrutamientoDeVistas}).
			
	
		 
		\subsection{back-end: Java (SpringBoot) y Python}
		
			- Back-end con Java (springboot para el login y la autenticación de usuarios: con este framework guardaremos datos en la BBDD mySQL).
			
			- Python dentro de un contenedor docker (o python a secas, para descargar los pdfs del correo) y parsear el contenido de los mismos: con sklearn, numpy y spacy que luego se podrán pasarlos a la BBDD mongoDB.
			
		\subsection{BBDD: MySQL y MongoDB}
		
		
		Para guardar los datos de los usuarios se debe usar un sistema de gestión de base de datos relacional. Hemos escogido MySQL dado que es el que hemos visto en el grado superior y estamos bien versados en ello.
		
		Sin embargo, los productos de Mercadona no los conocemos de antemano ni tenemos una lista exhaustiva de los mismos. Además, el número de productos que se pueden encontrar en un ticket varía en cada compra, por lo que no podemos usar una base de datos relacional tradicional como MySQL o PostgreSQL por que se trata de información no estructurada. En su lugar, usaremos MongoDB, una BBDD NoSQL que almacena datos en formato JSON y permite, además, búsquedas eficientes.
		
		Para optimizar el backend, intentaremos que un usuario pueda consultar repetidamente sus compras sin sobrecargar el servidor. La primera vez que consulte sus datos, estos se descargarán y almacenarán en localStorage del cliente. En consultas posteriores, los datos se obtendrán directamente de localStorage sin necesidad de hacer peticiones al servidor. Evaluaremos la viabilidad de este sistema durante el desarrollo; Esto es la fase de diseño y como tal, \textbf{PUEDE QUE EN LA FASE DE DESARROLLO CAMBIE}, en caso de no ser factible, las consultas se harán directamente en MongoDB.
		



		
		
		
		
		
		\section{Diagramas de la aplicación}
		
		\textbf{Fer un diagrama guapo de tots els components de l'aplicació.}
	
	\chapter{Desarrollo del proyecto} %OBLIGAT
	

	
	
				
			\section{GitHub del proyecto}
			
				Para desarrollar este proyecto se ha trabajado con GitHub y git. Dado que no ha habido trabajo en equipo no se han utilizado pull requests a la rama main sino simplemente se ha seguido la estrategia de crear ramas de característica y, una vez son satisfactorias, hacer un merge en la rama main en local.
				
				Un flujo de trabajo habitual es mediante ramas de característica (puede verse anexo \ref{sec:anexoFlujoGit}). También puede verse el GitHub del proyecto a continuación. Dentro del readme del proyecto encontraréis instrucciones para su descarga, clonado y ``despliegue'' (en local) de sus componentes en vuestro ordenador personal utilizando los servidores embedidos en los entornos de desarrollo de workbench, vscode e IntelliJ \textbf{PONER OTRO SI HACE FALTA} si así lo deseáis.
			

			
			
			
			
			
			
			
			
			
			
			
			
			\begin{table}[h!]
				\centering
				\begin{tabular}{|p{3.8cm}|p{11cm}|}
					\hline
					\textbf{Link al repositorio} & \href{https://github.com/blackcub3s/mercApp}{https://github.com/blackcub3s/mercApp} \\
					\hline
					\textbf{Página desplegada} & TO DO \\ % Corregido: Se eliminó la llave extra
					\hline
				\end{tabular}
				\caption{Enlaces importantes del proyecto.}
				\label{tabla:enlaces}
			\end{table}

	
	
		
			\section{Entornos de desarrollo}
			
				Para el back-end de Java con SpringBoot se ha utilizado el editor Java \texttt{IntelliJ Idea community edition} que expone el backend en el puerto\textbf{ 8080}: se han utilizado extensiones necesarias para correr el proyecto que permiten sacar provecho de Lombok sin las cuales correr el proyecto en IntelliJ fallará.
				
				Para el frontend se ha utilizado \texttt{VScode}, con la extensión live server para poder hacer llamadas al back-end directamente desde el puerto \textbf{5500}. Esto podría hacer las veces de una CDN donde podrían estar alojados los archivos estáticos (HTML, CSS y JavaScript).
		
	
		
			

			
			\section{desarrollo back-end (Spring Boot)}
			
				\subsection{Estructura de la aplicación}
				\label{sec:estructuraAplicacion}
				
				TO DO pom.xml application.properties, usuari, repository, service, controller.
				
				TO DO Parlar de les validacions i les anotacions 
				
				TO DO Parlar dels apartats de seguretat (segurity filter chain i JWT pero només de passada perque els mencionem despres)
				
				\subsection{Autenticacion y Autorización}
				
				\subsubsection{método utilizado: JWT}
				
				Para autenticar y autorizar a los usuarios no utilizaremos sesiones. Las sesiones, tal y como vimos en la asignatura de desarrollo web entorno servidor, requieren guardar un estado en el servidor (si tenemos 100 usuarios conectados necesitamos rastrear 100 personas en el servidor) y un identificador de sesión en una cookie segura con HttpOnly puesto a True guardada en el navegador de cada uno de los usuarios conectados que lo identifica en relación al servidor.
				
				Sin embargo, existe un método de acceso por token más escalable que no requiere guardar sesiones en el servidor (es decir, es un método ``stateless'' o sin estado) con el que nos basta tener solamente la Cookie Segura para guardarlo y ya está. Es un token que está autocontenido: es decir, puede contener ya el ID de usuario, nombre de usuario, roles que luego permitirán dar permisos o no en el servidor para acceder a determinadas APIs o recursos, etc. En definitiva, con JWT tenemos una autenticación más eficiente y un control del acceso preciso (autorización) sin necesidad de almacenar sesiones en el servidor.
				
				
				A este sistema lo llamamos JSON Web Token (\texttt{JWT}) y toda la información que contiene está encriptada o \textbf{firmada digitalmente} con SHA256 mediante una clave privada (el ``secret'') que solo tenemos nosotros en el servidor. Esta clave es igual para todos los tokens que generemos: la firma digital que emana de esta clave estará embedida, por así decirlo, en cada uno de esos tokens y \textit{será inválida} si un atacante ha modificado el token y nos lo devuelve al servidor tratando de suplantar la identidad de algún usuario; con ello, el servidor rechazará la integridad del token y evitará que pueda acceder a recursos del usuario al que trata de suplantar.
				
				JWT no es perfecto, por supuesto. Una desventaja del JWT es que una vez puesta una fecha de expiración el desarrollador ya no la puede cambiar. En las sesiones del servidor se pueden extender las sesiones si se detecta actividad del usuario, acortarlas si pasa justo lo contrario o incluso cerrar la sesión de un usuario en remoto; pero con JWT no es posible: una vez creado el Token de acceso la fecha de actividad del mismo no se puede modificar (porque no puedes invalidar un token ya existente!), lo cual permite que simplemente un atacante robe el token de acceso sin modificarlo y lo use hasta su fecha de expiración.
				
				Se proponen dos soluciones posibles a este problema, ninguna de las cuales ha sido implementada en este proyecto y queda definitivamente como uno de los puntos de mejora:
				
				\begin{itemize}
					\setlength{\itemsep}{.0em}
				
					\item 1. Tener dos tokens almacenados en el cliente: el ``access token'' que es el que permite autenticar y autorizar, del que hemos hablado hasta ahora; y otro token denominado ``refresh token'', que se utiliza
					para obtener un nuevo token de acceso cuando el token de acceso actual expire, o para obtener tokens de acceso adicionales con un alcance idéntico o más limitado -es decir, duración más corta- \cite{stackoverflow_refreshTokenAvantatjaSeguretat}
					
					\item 2. Crear una black-list de tokens de acceso donde se añadirán los usuarios que hayan hecho ``log out'' ANTES de la expiración programada de su token de acceso: así si un token de acceso todavía no expirado sabemos que su usuario se ha deslogueado, en caso que sea robado, el servidor rechazará la petición no permitiendo acceso a recursos \cite{stackOverflow_blackList}).
 
					
				\end{itemize}

				
				
				En este trabajo solo utilizaremos ``access tokens'' y ya está. Cuando un usuario se desloguee, lo que haremos será borrar el access token del local storage y ya está. Tampoco guardaremos los tokens en una cookie segura porque complica el desarrollo (de nuevo, otro punto a mejorar a futuro en este proyecto).
			
				 
				 \noindent En resumen, \texttt{las ventajas} que tiene JWT vs uso de sesiones (si asumiéramos que tanto el JWT como el SESSID se guardasen en una cookie segura, respectivamente) serían las siguientes:
				 
					\begin{tabular}{l}
						\textbf{- No depende del almacenamiento en el servidor} \\
						\textbf{- Firmado digitalmente} \\
						\textbf{- Mayor control sobre el acceso} \\
						\textbf{- Mayor descentralización} \\
						\textbf{- Menos carga para el servidor}
					\end{tabular}
									 
				   \noindent Y la \texttt{desventaja} más evidente que tiene JWT, es, en nuestra opinión, su complejidad\footnote{Se puede ver una tabla de diferencias más en profunidad, especialmente en materia de seguridad en el anexo \ref{sec:anexo_JWTvsSESSIONS})}, pues para tener un buen equilibrio entre facilidad de uso y seguridad es necesario almacenar los tokens en el cliente para conseguir que uno se renueve (el token de aceso y el de refresco, como comentamos):
				  
				  \begin{tabular}{l}
					 \textbf{- Caducidad de tokens irrevocable}\\
					 \textbf{- Renovación de tokens de acceso con uno de refresco}
				  \end{tabular}
				 

				
				
				
				\subsubsection{¿Qué compone un JWT?}
				\label{sec:queComponeJWTbackend}
				
				\noindent El JWT se compone de tres partes. \textbf{los headers}, \textbf{el payload} y \textbf{la signatura}. En la página \href{https://jwt.io/}{https://jwt.io/}, como veremos después, se puede ver si los tokens son válidos, observar su estructura interna, etc. \cite{jwtio}. A saber:
				

				\begin{itemize}
					\setlength{\itemsep}{-.5em}
					\item 				\textbf{Los headers}: Aportan información sobre el algoritmo que lo encriptó.
					\item 				\textbf{El payload}: Es donde está la información que nos interesa del token: el sujeto que lo generó (``sub''), el momento en que se generó el toquen (``iat'', o ``issued at'') y la fecha de expiración (``exp'' o ``expiration time''). También podemos tener ahí otros pares clave valor que podremos querer definir, por ejemplo, que contengan el id del usuario y sus roles o permisos que son los que nos permitirán dejar que un determinado usuario pueda consultar o no ciertos recursos.
					
					\item \textbf{La signatura}: Es la parte que garantiza la integridad del token y evita que sea alterado por terceros. Se genera aplicando un algoritmo de hash (en nuestro caso el SHA256) a la combinación del header y el payload, junto con la clave secreta que solo conoce el servidor (es lo que permetirá al servidor rechazar el token si no es válido -i.e. ha sido manipulado).
				\end{itemize}
				
				Podéis observar estas tres partes en colores en la figura \ref{fig:jwtioMostraPayload} que veremos después.
				
				
				

				

				
				
				\subsubsection{Implementación de JWT en java SpringBoot}
				\label{sec:implementacionJWTjava}
				Para poder implementarlo añadimos la dependencia \textbf{jjwt} en \texttt{pom.xml} que es la que nos permite definirlo.
				
				
				\begin{lstlisting}[language=XML, basicstyle=\ttfamily\small, keywordstyle=\color{red}]
					
	<dependency>
		<groupId>io.jsonwebtoken</groupId>
		<artifactId>jjwt</artifactId>
		<version>0.12.6</version>
	</dependency>
					
				\end{lstlisting}
				
				
		En el proyecto se han creado tres clases dentro de sus respectivos archivos en la ruta \texttt{src/main/java/} \texttt{miApp.app/seguretat/jwtseguretat} denominadas:
		
		\begin{itemize}
			\setlength{\itemsep}{-.4em}
			\item \textbf{JwtUtil}
			\item \textbf{AccessToken}
			\item \textbf{RefreshToken}
		\end{itemize}
		  
		
		En la clase \textbf{JwtUtil} hemos creado un método que obtiene las \textit{claims} (pares clave valor que contienen la carga útil de un JWT) y en el constructor hemos creado la definición de una clave privada con la que derivar todas las instancias que hagamos de esa clase -es decir, todos los tokens que se cifren con esa contraseña-. De esta clase hemos heretado las otras dos: La subclase que nos genera el \textit{token de acceso}, \textbf{AccessToken}; y la que nos genera el \textit{token de refresco}, \textbf{RefreshToken}. A continuacion podéis, de estas tres, la más importante (la clase RefreshToken la hemos programado para usarla a futuro pero no se ha utilizado para la implementación del sistema de autenticación y autorización en este proyecto): 
		
		

		
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]
				
@Component
public class AccessToken extends JwtUtil {
	
  private static int tExpM; //minuts per a exprirar el token
	
  public AccessToken() {this.tExpM = 10;}
	
  //FINALITAT: Generar un JWT d'acces.
  public String genera(String correu, int idUsuari, byte permisos) {
	Map<String, Object> dadesExtraApayload = new HashMap<>();
	dadesExtraApayload.put("permisos", permisos);
	dadesExtraApayload.put("idUsuari", idUsuari);
		
	return Jwts.builder()
	 .setClaims(dadesExtraApayload) //dades customitzades
	 .setSubject(correu)            //guardo nom subjecte (clau "sub")
	 .setIssuedAt(new Date())       //data creacio (clau "iat" payload)
	 .setExpiration(new Date(System.currentTimeMillis() + (tExpM*60*1000)))
	 .signWith(SignatureAlgorithm.HS256, clauSecreta.getBytes())
	 .compact();
}


\end{lstlisting}
		
		
		
		Con la función \textbf{genera()} de la clase AccessToken arriba mostrada, y con los parámetros necesarios que serán necesarios para autorizar (idUsuari) y autenticar (permisos), podemos generar un token de acceso en ``accesJWT'' que es el que usamos en la aplicación para permitir acceder a los endpoints o no:
		
		
		
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]

AccessToken accessToken = new AccessToken();
String accesJWT = accessToken.genera(
	"santo@gmail.com",  //campoSub
	2, //idUsuari
	1  //permisos
);


\end{lstlisting}
		
		Si vemos la figura \ref{fig:jwtioMostraPayload} que tenemos a continuación, veremos en la mitad izquierda un token de acceso generado por la función anterior. Fijémonos que internamente ese token está estructurado en las tres partes de la parte derecha de la imagen, siendo la payload la más importante:
		
	
			\setlength{\belowcaptionskip}{3pt}
			\FloatBarrier
			\begin{figure}[H]
				\centering
				\caption{Decodificación mediante \href{https://www.jwt.io}{jwt.io} de un token de acceso usado en nuestra aplicación generado con la función ``genera()'' de la clase AccessToken. La Payload con las claims en flecha verde.}
				\includegraphics[width=1\textwidth]{img/jwtio_mostra_payload.png}

				\label{fig:jwtioMostraPayload} 
			\end{figure}
			\FloatBarrier

		
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]
			
		
		{
		    "permisos": 1,
		    "idUsuari": 2,
		    "sub": "santo@gmail.com",
		    "iat": 1743152350,
		    "exp": 1743152950
		}
			
\end{lstlisting}
		
		
		
		
		
		Al generar las tres clases hemos utilizado herencia porque la clave privada es la misma para ambos tipos de token (tanto el de acceso como el de refresco), mientras que los métodos para generar cada uno de los dos tipos de token cambian. En StackOverflow existe un debate para ver si hay que tener una clave privada distinta para cada tipo de token, por si el lector está interesado \cite{stackoverflow_jwt_refresh_token_secret}. Después de ver la entrada en stackOverflow Se ha optado por compartir claves para ambos tipos.
		
		
		En la clase \textbf{JwtUtil} tenemos una función denominada \texttt{getClaims()} que es la que utilizaremos en el Service de nuestra aplicación para poder autenticar y autorizar usuarios. Las tres clases pueden ser consultadas en el anexo \ref{sec:anexoCreacionYverificacionJWT} o en el GitHub del proyecto (\href{https://github.com/blackcub3s/mercApp/blob/main/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/jwt}{link}). Se recomienda encarecidamente al lector optar por esta última opción\footnote{Al poner las tres clases en anexo se omitieron las funciones main donde se testeaban las funciones de creación de tokens con control de excepciones, comentarios e imports por falta de espacio en el DIN A4.}.
		
		\subsubsection{Enviar por primera vez el Access Token hacia el front-end}
		\label{sec:enviarPorPrimeraVezAccesTokenDESDEBACKEND}
		
		Cuando el usuario consigue poner la contraseña correcta en la página del front-end \textbf{pas2C\_login.html} se manda de vuelta del back-end (desde el controlador de endpoint \texttt{/login}) hasta el front-end en el localStorage (¡en esto proyecto lo hemos hecho así por simplicidad, pero en producción, insistimos, debería estar en una cookie segura!).
		
		La parte de recepción del token en el front-end y de su manejo podéis encontrarla en el apartado \ref{sec:recibirAccesTokenENFRONTEND}

		
		
		
		
		
		
		\textbf{TO DO: Referenciar endpont login springboot (que cal millorar)}
		
		\subsubsection{Recibir el JWT enviado por el front-end, interpretarlo desde el back-end y con ello securizar un endpoint de la API desde el back-end}
		
		Después de crear las tres clases en Java de las que hemos hablado en el apartado \ref{sec:implementacionJWTjava} anterior y haber mandado el token de acceso al front, podemos empezar a 
		implementar la protección de endpoints con JWT. Asumamos que nos llega al back-end un token de acceso en una solicitud HTTP de un usuario que ya acaba de recibir su token y quiere acceder al dashboard de visualización (a través de la heather ``Authorization''). La solicitud HTTP con el susodicho token se hace via GET a (\texttt{'usuaris/{id}/tiketsVERIFICARSIEXISTEIX'}) (ver subseccion \ref{sec:estructuraAplicacion}, en ControladorUsuari.java). 
		
		En javascript puro, desde el cliente, esta solicitud HTTP la pondríamos conseguir de la función fetch(), poniéndole uno de los pares clave valor con el inicio ``Bearer'' (por convenio) tal que así:
		
				
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]

fetch("'http://localhost:8080/usuaris/{id}/endpointTikets'", {
	method: "GET",
	headers: {
		"Content-Type": "application/json",
		"Authorization": "Bearer "+tokenJWT;
	},
	...
}
\end{lstlisting}
		
		 Queremos conseguir que ese endpoint permita en cada solicitud \textbf{Autenticarlo}, es decir, determinar que dice ser quien es mediante el hecho de encontrar en el token verificado su \textcolor{red}{idUsuari} correspondiente (y acceder a la información de sus tickets); y a su vez \textbf{Autorizarlo}, es decir, dar acceso a ese usuario a los recursos a los que se le permita acceso mediante la variable \textcolor{orange}{permisos} correspondiente.
		
		 Estos dos pasos irán en función del valor de la variable que haya emanado de la base de datos al conceder el token mediante \textcolor{red}{idUsuari} para el caso de la \textbf{Autenticación} -ver \href{https://github.com/blackcub3s/mercApp/blob/b01cec515bb9af27a1faa24258abb4313ef275cd/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/Usuaris/model/Usuari.java#L30}{linea github}-, y de la variable \textcolor{orange}{permisos} del model de la @Entity class Usuari - ver \href{https://github.com/blackcub3s/mercApp/blob/b01cec515bb9af27a1faa24258abb4313ef275cd/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/Usuaris/model/Usuari.java#L42}{linea github}- para el caso de la \textbf{autorización}). Para ello hay \textbf{tres} pasos que debemos implementar dentro del back-end de SpringBoot:
		
		
		
		
		\begin{itemize} 
			\setlength{\itemsep}{-1.5em}
			\item \textbf{PASO 1:} Extraer la información del usuario autenticado desde \textit{el payload} del token JWT entrante. Para ello crearemos un \textbf{Filtro de Autenticacion} dentro de \texttt{FiltreAutenticacio.java}\\
			\item \textbf{PASO 2:} Configurar el contexto de seguridad para que Spring Security reconozca los permisos, dentro de  \texttt{ConfiguracioSeguretat.java}. \\ 	
			\item \textbf{PASO 3:} Aplicar restricciones con \textbf{@PreAuthorize} en cada \textit{endpoint} que queramos proteger en el controlador, dentro \texttt{UsuariControlador.java}
		\end{itemize}
		

		\noindent \textbf{PASO 1: Extracción del payload (\textit{FiltreAutenticació.java})}
		\hrule
		
		Esta parte del código está llena de boilerplate. La clase \textit{FiltreAuntenticacioJwt.java} extiende de OncePerRequestFilter \cite{oncePerRequestFilter}, que como dice el propio nombre de la clase implementa un filtro que se desarrollará una y solo una vez por cada petición al servidor.
		
		Lo que hay que hacer aquí es implementar el método \textit{doFilterInternal()} donde colocamos la lógica específica del filtro. Se puede consultar este archivo en github del proyecto \href{https://github.com/blackcub3s/mercApp/blob/main/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/FiltreAutenticacioJwt.java}{FiltreAuntenticacioJwt.java}
		
		Lo primero que hay que tener en cuenta al diseñar esta clase es que tenemos que hacer una inyección de dependencias: debemos incluir la clase que hemos diseñado AccessToken para implementar el token de acceso. Lo haremos simplemente incluyéndola en el constructor como un parámetro.
		
		Lo segundo que hay que considerar es la extracción del payload del token (donde tenemos la información que nos permitirá autorizar y autenticar). Para encontrar el token se hace de la \textbf{cabecera} ``Authorization'' de la solicitud HTTP entrante del front-end. La clave es ``Authorization'' y el valor asociado es, por convenio, un String ``Bearer '' concatenado al token de interés; algo así:
		

		
		\FloatBarrier
		\begin{table}[h]
				\centering
 				\textit{``Authorization'' : ``Bearer OJALWQ03P1WNOEGBO...''}
		\end{table}
		\FloatBarrier
		

		 
		  La programación necesaria para conseguir lo mencionado en el párrafo anterior queda recogida en este rango de lineas de GitHub (\href{https://github.com/blackcub3s/mercApp/blob/89efcf854d8bbab2addde3f7e817eb97f7737b95/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/FiltreAutenticacioJwt.java#L33-L43}{ver rango}). 
		  
		  Luego una vez tenemos el token dentro de Spring Boot tratamos de sacar las Claims del Payload, es decir, la carga útil del token (\href{https://github.com/blackcub3s/mercApp/blob/89efcf854d8bbab2addde3f7e817eb97f7737b95/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/FiltreAutenticacioJwt.java#L50-L54}{ver rango}). Y con ello ya podemos asignar roles a partir de la variable permisos del payload (es decir, 0 1 o 2 en función de si no tiene ninguna autorización todavía, 1 si ya tiene acceso a los recursos de la web como podría ser consultar el dashboard de la aplicación y 2 si es superusuario - \href{https://github.com/blackcub3s/mercApp/blob/89efcf854d8bbab2addde3f7e817eb97f7737b95/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/FiltreAutenticacioJwt.java#L56-L66}{Ver rango} -). En definitiva, lo de éste párrafo (pos si se imprimió la memoria y no hay acceso a github) sería esto:
		  
		  
		  
		  \begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]
		  
	Claims claims = accessToken.getClaims(token);
	
	
	Integer permisos = (Integer) claims.get("permisos"); 
	Integer idUsuari = (Integer) claims.get("idUsuari"); 
	
	// Creo autoritat basada en permisos
	String role;
	if (permisos == 2) {
	  	role = "ROLE_ADMIN";
	} else if (permisos == 1) {
	  	role = "ROLE_USER";
	} else {
	  	role = null;
	}
		  
		  \end{lstlisting}
		  
		  Importante es mencionar que en el fragmento de código anterior, al llamar la el método $getClaims(token)$  se lanzará una excepción de tipo \textit{ExpiredJwtException} en caso que el token haya expirado, que recogemeremos en el primer bloque Catch; y si el token está manipulado y no es válido, entonces se lanzará otra excepción que se recogerá en el segundo bloque Catch. Todo ello se informará como una response al cliente ( \href{https://github.com/blackcub3s/mercApp/blob/89efcf854d8bbab2addde3f7e817eb97f7737b95/APP%20WEB/__springboot__produccio__/app/src/main/java/miApp/app/seguretat/FiltreAutenticacioJwt.java#L96-L115}{ver rango codigo}).
		  
		  
		  Y finalmente hay que crear un objeto de tipo \textit{UsernamePasswordAuthenticationToken} ya definido dentro de SpringBoot. Su constructor permitirá tres parámetros: 
		 
		 	\begin{itemize}
		 	\setlength{\itemsep}{-.5em}

			  \item \textbf{el principal}, el primero, al que le pasaremos el \textcolor{red}{idUsuari}
			 \item  \textbf{credentials}, el segundo, que lo dejamos a null porque en JWT no se debe manejar credenciales ya que están contenidas dentro del token. 
			  \item \textbf{una collection con el role}, el tercero, que contendrá los roles que definimos antes. 
		  \end{itemize}
		  Este constructor nos permitirá restringir permisos para las APIs según el \textcolor{red}{idUsuari} al que esté vinculado su login (autenticación) y también según el valor de \textcolor{orange}{permisos} que tenga (autorización)\footnote{Cuidado! Lo cierto es que deben considerarse ambos parámetros a la vez en el controlador, como veremos en el paso 3. No es suficiente añadir roles a un determinado id. Solamente con los roles, Spring Boot no nos dejará, por ejemplo, que en una API que toma el idUsuari como parámetro en la URL (como la de este ejemplo) se pueda restringir a ese usuario específico para que no consulte los recursos de los demás usuarios con idUsuari distintos.}.
		  

		  
		  
 \begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]
	  	
UsernamePasswordAuthenticationToken authentication = 
new UsernamePasswordAuthenticationToken(
	idUsuari,
	null,
	Collections.singletonList(new SimpleGrantedAuthority(role))
);



 \end{lstlisting}
Este objeto \textit{authentication} que acabamos de crear entonces tenemos que guardarlo DENTRO del SecurityContextHolder:

		 
 \begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]

 SecurityContextHolder.getContext().setAuthentication(authentication)
	
\end{lstlisting}
	
	
	


		\noindent \textbf{PASO 2: Configuración contexto de seguridad}
		\hrule
		
		lorem ipsum
		
		\noindent \textbf{PASO 3: Restricciones en el controlador}
		\hrule
		


		
		lorem ipsum
		
		
			\subsection{validación de datos (End-points back)}
			\label{sec:validacioDadesBACK}
			
			\textit{NOTA: Los datos validados en el back-end siguen las mismas expresiones regulares y restricciones que las validaciones hechas en el front-end (ver sección \ref{sec:validacioDadesFRONT}).}
			
			Los endpoints del back-end a los que apuntamos con llamadas fetch desde los campos de formulario de correo electrónico y contraseña desde el HTML deben protegerse también en el back-end, no solamente en el front.
			
			El motivo de ello es porque no podemos permitir que entren unos datos no validados (nulos, con caracteres peligrosos) a través de \textbf{llamadas directas a la API}. Hay que tener mucho cuidado con esto!
			
		\textbf{	TO DO }
			

		
	\section{desarrollo back-end (microservicio con Python)}
	
	
	
	
	
	\section{desarrollo del front-end}
	
	\subsection{Enrutamiento de vistas}
	\label{sec:EnrutamientoDeVistas}
	
	Para esta aplicación vamos a tener \textbf{una serie de vistas} a las que el usuario va acceder en función del valor de la variable ``permisos'' en la tabla ``usuaris'' de mySql y de si el usuario está ``loqueado'' o no.
	
	Como hemos especificado en el Apartado de diseño, nos hemos inspirado para ello en un proceso de desarrollo inverso del proceso de registro de la plataforma NetFlix. El esquema simplificado del proceso de enrutamiento durante el registro de un usuario en NetFlix queda recogido en el diagrama del anexo (ver apartado \ref{sec:anexo_diagramaNetflix}) y puede consultarse también en uno de los repositorios de mi github (\href{https://www.github.com/miApp}{link}). 
	
	El proceso de registro que utilizamos aquí es, justamente, una derivación del mismo: pero en este caso no se utilizan redirecciones a cartas de pago sino que redirigimos al usuario a una de dos páginas posibles según su caso particular con los permisos. Una, es una página para darnos acceso al gmail donde Mercadona envía al usuario los tickets digitales para así poder nosotros descargarlos y procesarlos: \texttt{pas4\_ConcedirAccesGmail.html}; la otra es \texttt{dashboard.html}, donde se visualizan el resultado de la minería y extracción de datos de esos tikets, como vemos en el diagrama de la figura \ref{fig:diagramaMercaAppFront}:
	
	\begin{itemize}
		\setlength{\itemsep}{.0em}
		
		\item 1. Decisiones del back-end de Spring Boot al llamar a APIs (\textbf{\textcolor{yellow!75!black}{\underline{rombos amarillos}}}). %75 per cent groc i 25 negre entenc
		\item 2. Las APIs mencionadas, indicadas entre corchetes y con colores:
		\begin{itemize}
			\setlength{\itemsep}{.0em}
			\item \textbf{\textcolor{red}{[\texttt{/api/avaluaUsuari}]}}: evalúa si el correo electrónico introducido pertenece a un usuario registrado.
			\item \textbf{\textcolor{brown}{[\texttt{/api/registraUsuari}]}}: registra un nuevo usuario en el sistema y expide su AccessToken con permisos a 0 en las claims \footnote{El lector puede consultar la explicación sobre lo que son las claims y el payload de un JWT en el apartado \ref{sec:queComponeJWTbackend}.}
			\item \textbf{\textcolor{blue}{[\texttt{/api/login}]}}: gestiona el proceso de autenticación y generación del \textit{JWT Access Token} con tres niveles de permisos posibles (0, 1 y 2).
		\end{itemize}
		
		
		
		\item 3. Las vistas (archivos html, en \textbf{\textcolor{orange}{\underline{rectángulos naranja}}}) a las que redirige JavaScript mediante $window.location.href$ a partir de los resultados de las llamadas a las APIs.
		
		\item 4. Expedición de tokens de acceso (JWT) con (\textbf{\textcolor{blue!40!white}{\underline{rectangulo de fondo azul}}}) con permisos embedidos en las claims.
		
	\end{itemize}
	
	
	
	
	\setlength{\belowcaptionskip}{3pt}
	\FloatBarrier
	\begin{figure}[H]
		\centering
		\caption{Diagrama de flujo del enrutamiento comlpeto del sistema \textit{front-end} durante el proceso de registro, desde que el usuario introduce su correo en \texttt{pas1\_LandingSignUp.html} hasta que obtiene acceso al \texttt{dashboard}.}
		\includegraphics[width=1\textwidth]{img/diagramaMercAppFront.pdf}
		
		\label{fig:diagramaMercaAppFront} 
	\end{figure}
	\FloatBarrier
	
	
	
	
	
	
	
	
	\subsection{Manejar vistas en función de Autenticación y autorización}
	
	
	Como hemos visto antes Podemos considerar que cada archivo HTML y su CSS asociado es una ``vista'' de nuestra aplicación. Habrá vistas que \textbf{no nos interesará enseñar a ciertos usuarios}, porque o bien no serán relevantes para ellos o bien harán llamadas a APIs cuya información no podrá ser obtenida para ellos.
	
	Si bien Spring Boot permite servir los archivos estáticos\footnote{HTML, CSS y JS son archivos estáticos.}  de dentro del mismo back-end de Spring Boot y utilizar un sistema de plantillas (Thymeleaf) esto realmente no es, para nada, lo ideal. Lo ideal es definir un front-end y un back-end separados partiendo de principios de \textit{separación de responsabilidades} o \textit{SoC}\footnote{Separation of concerns}, y así lo hemos hecho en este proyecto\footnote{Si tenemos ambas partes desacopladas podremos hacer modificaciones independientes en ambas. Por ejemplo, podremos cargar los archivos front-end en una CDN o un Proxy o tenerlos cacheados en un servidor que los sirva mucho más rápido, como Nginx. Es más, lo óptimo sería generar los archivos del front-end mediante un sistema de desarrollo por componentes (como Angular, React o Vue) para facilitar el desarrollo cuando la aplicación crezca y utilizar una paradigma \textit{SPA} (\textit{Single Page Application}). Sin embargo, en este caso, por el tiempo disponible y el tamaño de la aplicación se ha optado por hacerlo con HTML, CSS y JS puros.}. Las ventajas son evidentes:
	
	\begin{itemize}
		\setlength{\itemsep}{.0em}
		\item \textbf{Responsabilidad única (SRP)}: Cada módulo debería hacer una sola cosa ($\{$Frontend $\rightarrow$ interfaz$\}$, $\{$Backend $\rightarrow$ procesamiento$\}$). 
		\item \textbf{mantenibilidad}: Al usar una arquitectura modular cada parte puede evolucionar por separado. Podemos desplegar solo el front o el back. En el futuro podremos cambiar el front-end de archivos estáticos por un front-end con Angular, por ejemplo.
		\item \textbf{Escalabilidad}: Según la carga podemos escalar independientemente ambas partes del proyecto. Por ejemplo, poner los archivos estáticos (html, css y js del front-end) en un servidor para servirlos rápidamente como nGinx \cite{nginx} (supuestamente más rápido que Apache). Dejar en el tomcat embedido de springboot el procesamiento del back-end y si hay problemas de escalabilidad escalar este independientemente en AWS, AZURE, o en un servidor propio según sea más conveniente.
		\item \textbf{Reutilización}: Un backend puede servir varios front-ends (no solo web, sino móvil también). El mismo front-end podemos reutilizarlo luego para otra aplicación con un back-end en otro lenguaje por ejemplo.
	\end{itemize}
	
	
	
	
	
	Sin embargo, no todo es ideal. Siempre existen concesiones (o como diríamos en inglés ``trade-offs''). Al tener el front-end y el back-end desacoplados esto también aumenta considerablemente la complejidad inicial en el desarrollo: la protección de las vistas se hace más difícil porque no las sirve el back-end y no las puede proteger directamente este\footnote{A diferencia de lo que sí haría una aplicación back-end hecha en php tradicional como las que hemos visto en desarrollo web entorno servidor, donde servimos el HTML desde dentro del mismo PHP).}.
	
	Por ejemplo, del mismo modo que los endpoints de nuestra API del back-end en Spring Boot están protegidos y no devuelven datos cuando el JWT de acceso que tengamos en el front-end haya caducado, sea inexistente, o sea inválido (porque haya sido manipulado o no tenga el ``idUsuari'' que permita el acceso a un cierto recurso), también pasará que ciertas páginas del front-end no podrán obtener la información deseada si llaman a un end-point para el que no tienen autorización: En este caso deberemos modificar su DOM para la ocasión mostrando un mensaje de error, instando al usuario a iniciar sesion y/o bien redirigir al usuario a la página correcta, por ejemplo.
	
	Con tal de conseguirlo, deberemos manejar la lógica en cada caso particular desde el front-end usando JavaScript. Tengo entendido que en frameworks como Angular esto se puede hacer de forma muy sencilla, solo definiéndolo en una ocasión. Aquí cada página particular requerirá una programación específica con JavaScript.
	
	\subsubsection{Protegiendo las vistas: permisos}
	
	Se establecen tres niveles de permisos en la aplicación que tienen un impacto en qué puede visualizar el usuario ``logueado'' y qué no; y cómo se permite que el usuario navegue a medida que va moviéndose en el proceso de registro cuando no está ``logueado''. Estos permisos tienen un impacto en el enrutamiento del front-end de la aplicación (su impacto podemos verlo en la parte superior derecha de la figura del enrutamiento \ref{fig:diagramaMercaAppFront}) y más resumidamente en el cuadro \ref{table:permisos}:
	
	\begin{table}[H]
		\centering
		\caption{Significado del valor de la variable \texttt{permisos} en la tabla mySQL\texttt{usuaris}}
		\begin{tabular}{|c|l|}
			\hline
			\textbf{\texttt{permisos}} & \textbf{Significado} \\
			\hline
			0 & No hay acceso a tickets digitales \\
			1 & Acceso a tickets como usuario (USER) \\
			2 & Acceso a tickets como administrador (ADMIN) \\
			\hline
		\end{tabular}
		\label{table:permisos}
		
	\end{table}
	
	\textbf{Parlar de les proteccions de les vistes programmatically via javascript. Posar captura d'alguns dels scripts. No paralar de JWT en aquest apartat, referenciar al seguent (para entender como guardamos los datos de permisos e ide de usuario en el front, podemos ver el apartado del token de acceso: \ref{sec:recibirAccesTokenENFRONTEND})}
	
	\subsubsection{Recibir el Access Token desde el back-end}
	\label{sec:recibirAccesTokenENFRONTEND}
	
	El token de acceso se recibe por primera vez en el cliente cuando el usuario se \textbf{loguea con éxito} mediante la llamada fetch() hacia el endpoint del back-end ``\textit{/api/login}''. 
	
	Esta recepción se produce cuando, por un lado, en el JavaScript embedido, dentro de \textit{pas2Clogin.html}, obtenemos el código 200 (OK) del servidor, pero también se cumple que usuario y contraseña son correctos. Si y solo si se cumplen ambas condiciones, se extrae el token de acceso del body que obtenemos, que será uno como este, y podremos guardarlo en el LocalStorage del navegador\footnote{Esto lo hacemos para luego poder mandarlo de vuelta al servidor en la subsecuentes solicitudes que requieran autentizcación y autorización.} (véase figuras y \ref{fig:FetchCodisResponseFRONT} y \ref{fig:figuraLoginFetch}):
	
	:
	
	\begin{lstlisting}[language=Java, basicstyle=\ttfamily\footnotesize, keywordstyle=\color{magenta}]
		{
			"usuari": {
				"alies": "the protein kingdom",
				"permisos": 2,
				"idUsuari": 1
			},
			"existeixUsuari": true,
			"AccessToken": "eyJhbGciOiJIUzI1NiJ9.eyJwZXJ [...]",
			"teAccesArecursos": true,
			"contrasenyaCorrecta": true
		}
	\end{lstlisting}
	
	
	
	\setlength{\belowcaptionskip}{3pt}
	\FloatBarrier
	\begin{figure}[H]
		\centering
		\caption{Fragmento de codigo en pas2C\_login.html dentro del codigo javascript para manejar codigos de error. Cuando el back-end de SpringBoot devuelve el código 200 significará que podremos extraer los datos del body de la. 400 se devolvería si hubiera problemas validación de campos en el back-end,  algo que no debería producirse nunca con el front-end que se ha programado}
		\includegraphics[width=1\textwidth]{img/FetchCodisResponseFRONT.png}
		
		\label{fig:FetchCodisResponseFRONT} 
	\end{figure}
	\FloatBarrier
	
	\setlength{\belowcaptionskip}{3pt}
	\FloatBarrier
	\begin{figure}[H]
		\centering
		\caption{Fragmento de codigo en pas2C\_login.html dentro del codigo javascript para obtener el token de acceso (detalle en rojo).}
		\includegraphics[width=1\textwidth]{img/jwtFetchLoginFront.png}
		
		\label{fig:figuraLoginFetch} 
	\end{figure}
	\FloatBarrier
	
	
	Para entender de dónde viene el token desde el back-end redirigimos al lector a la sección \ref{sec:enviarPorPrimeraVezAccesTokenDESDEBACKEND}, donde se trata ese aspecto. En la presente sección nos ocuparemos de JavaScript en el front.
	
	En este trabajo no implementaremos cookies ya que implica configuración extra tanto en el cliente como en el servidor. Vamos a guardar el token en el cliente en el localStorage (que es, de hecho, una práctica habitual en aplicaciones que no requieren un alto grado de seguridad). También hay que mencionar sobre que existe un debate para ver si en ese logIn el token de acceso recién generado en el servidor se debe mandar al cliente en el body de la respuesta de la solicitud POST \textit{o bien} en la header ``Authorization''. 
	
	Sin embargo, es práctica común mandarlo en el body. Nótese, que para el paso inverso (cliente a servidor) sí debe mandarse en el Heather "Authorization". 
	
	
	
	\subsection{validacion de datos (Formularios entrada)}
	\label{sec:validacioDadesFRONT}
	
	\textit{NOTA: Los datos validados en el front-end siguen las mismas expresiones regulares y restricciones que las validaciones hechas en el back-end (ver sección \ref{sec:validacioDadesBACK}).}
	
	\textbf{TO DO FER-HO}
		
		
	\chapter{Evaluación y Conclusiones Finales} %OBLIGAT
	

	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	\chapter{ANEXO}
	\label{chap:anexo} % Esta es la etiqueta de referencia
		
			
		\section{Flujo de trabajo habitual en git}
		\label{sec:anexoFlujoGit}
		
\begin{lstlisting}[language=bash, basicstyle=\ttfamily\small]
	


# trabajamos con el proyecto y se introduce
# en el staging area
git add -A 

# creamos rama para aglutinar los cambios
git branch backEnd

# cambiamos a la rama que acabamos de crear
git checkout backEnd

# guardamos los cambios como nodos dentro de
# la rama con la que desarrollamos.	
git commit -m "commit 1"  	
git commit -m "commit 2"
# [...]
git commit -m "commit n"

#cambiamos a rama main local y luego integramos cambios
git checkout main
git merge backEnd

#Subimos los cambios al repo remoto
git push origin main 

	
\end{lstlisting}
		
	
\pagebreak

		
		
		\section{Diferencias de seguridad: JWT vs SESSID en cookies seguras}
		\label{sec:anexo_JWTvsSESSIONS}
						
			\FloatBarrier
			\begin{table}[h]
				\centering
				\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
					\hline
					\textbf{Característica} & \textbf{JWT en cookies seguras} & \textbf{Session ID en cookies seguras} \\
					\hline
					\textbf{Seguridad contra XSS} & Más seguro si la cookie tiene \texttt{HttpOnly} y \texttt{Secure}, ya que no es accesible desde JavaScript. & Más seguro si la cookie tiene \texttt{HttpOnly} y \texttt{Secure}, ya que no es accesible desde JavaScript. \\
					\hline
					\textbf{Seguridad contra CSRF} & Puede ser vulnerable si la cookie no tiene \texttt{SameSite=Strict}. & Menos vulnerable si la cookie tiene \texttt{SameSite=Strict}. \\
					\hline
					\textbf{Estado en el servidor} & Stateless (no hay estado en el servidor, el JWT contiene toda la información). & Stateful (el servidor mantiene una sesión activa asociada con el Session ID). \\
					\hline
					\textbf{Escalabilidad} & Mejor escalabilidad porque no requiere almacenamiento de sesiones en el servidor. & Menos escalable, ya que el servidor debe manejar las sesiones activas. \\
					\hline
					\textbf{Expiración y revocación} & Difícil de revocar antes de que expire, a menos que se implemente una lista negra en el servidor. & Fácil de invalidar eliminando la sesión en el servidor. \\
					\hline
					\textbf{Uso con JavaScript} & No accesible desde JavaScript si la cookie tiene \texttt{HttpOnly}. & No accesible desde JavaScript si la cookie tiene \texttt{HttpOnly}. \\
					\hline
				\end{tabular}
				\caption{Comparación de seguridad entre JWT y Session ID almacenados en cookies seguras con HttpOnly=True.}
				\label{tab:jwt_vs_session}
			\end{table}
			\FloatBarrier
	
		\pagebreak
		
		
		\section{Clases para crear y verificar JWTs}
		\label{sec:anexoCreacionYverificacionJWT}
	
	
\subsection{Clase JWT}


\begin{lstlisting}[language=Java, basicstyle=\ttfamily\tiny, keywordstyle=\color{magenta}]
	
//NO INSTANCIEM AQUESTA CLASSE MAI. LA FEM ABSTRACTA
@Component
public abstract class JwtUtil {
	
	//es la clau privada de 256 bits com a minim per encriptar el token (tant el d'acces com el de refresh)
	//veure debat http://bit.ly/3RmBGIK
	protected static String clauSecreta;
	
	public JwtUtil() {
		this.clauSecreta = "a8f7d9g0b6c3e5h2i4j7k1l0m9n8p6q3r5s2t1u4v0w9x8y7z";
	}
	
	//METODE QUE PARSEJA EL TOKEN JWT COMPLET. VERIFICA LA FIRMA I EXTRAU LES CLAIMS (parells clau valor en el payload).
	protected Claims getClaims(String token) {
		return Jwts.parser()
		.setSigningKey(clauSecreta.getBytes())
		.build()
		.parseClaimsJws(token)
		.getBody();
	}
	
}






\end{lstlisting}


				

\subsection{Clase Refresh Token}

\begin{lstlisting}[language=Java, basicstyle=\ttfamily\tiny, keywordstyle=\color{magenta}]

@Component
public class RefreshToken extends JwtUtil {
	
	private static int tExpDies;
	
	public RefreshToken() {this.tExpDies = 7;}
	
	// FINALITAT DEL METODE: Refrescar el token d'acces que genera generaAccesToken().
	public String generaRefreshToken(String correu, int idUsuari) {
		Map<String, Object> dadesExtraApayload = new HashMap<>();
		dadesExtraApayload.put("idUsuari", idUsuari);
		//posar mes dades al payload si es necessari
		
		return Jwts.builder()
		.setClaims(dadesExtraApayload) //dades customitzades
		.setId(String.valueOf(UUID.randomUUID().toString())) //id unic per a token. Per traSSSabilitat
		.setSubject(correu)           //guardo nom subjecte (dins "sub")
		.setIssuedAt(new Date())      //data creacio
		.setExpiration(new Date(System.currentTimeMillis() + tExpDies*86400*1000))  //expiracio
		.signWith(SignatureAlgorithm.HS256, clauSecreta.getBytes())
		.compact();
	}
}

\end{lstlisting}


\subsection{Clase Access Token}
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\tiny, keywordstyle=\color{magenta}]

@Component
public class AccessToken extends JwtUtil {
	
	private static int tExpM; //minuts per a exprirar el token
	
	public AccessToken() {this.tExpM = 10;}
	
	//FINALITAT: Generar un JWT d'acces.
	public String genera(String correu, int idUsuari, byte permisos) {
		Map<String, Object> dadesExtraApayload = new HashMap<>();
		dadesExtraApayload.put("permisos", permisos);
		dadesExtraApayload.put("idUsuari", idUsuari);
		
		return Jwts.builder()
		.setClaims(dadesExtraApayload) //dades customitzades
		.setSubject(correu)            //guardo nom subjecte (clau "sub")
		.setIssuedAt(new Date())       //data creacio (clau "iat" payload)
		.setExpiration(new Date(System.currentTimeMillis() + (tExpM*60*1000)))
		.signWith(SignatureAlgorithm.HS256, clauSecreta.getBytes())
		.compact();
	}
}
	
				
\end{lstlisting}
	

	
		\section{Diagrama réplica netflix}
		\label{sec:anexo_diagramaNetflix}
		
		\includegraphics[width=1\textwidth]{img/diagramaTikzDefinitiuV2.pdf}

		NOTA: El lector puede ver el proceso de creación de este diagrama en el repositorio \href{https://github.com/blackcub3s/diagramaTikz}{diagramaTikz}. También puede ver una explicación del diagrama a continuación:
		
		Este diagrama se puede entender del siguiente modo:
		
		\begin{enumerate}
			\item Cada rectángulo de color naranja es una página estática \texttt{.html} de lo que sería una réplica de la página de registro de netflix.
			\item Cada rombo de fondo amarillo es una decisión que se hará dentro del back-end de Spring Boot, dado que requiere hacer consultas a la BBDD y contiene datos sensibles.
			\item Los rombos de fondo azul se decidirán en el front-end en tanto que sus decisiones no requieren consultar información personal en la base de datos y no precisan, por lo tanto, del uso del back-end (y, además, no se explicarán en este \textit{readme}).
			\item El paréntesis que incluye la extensión de una URL debajo de cada rectángulo naranja es cada página de Netflix cuyo comportamiento y, en menor medida, aspecto, se ha intentado replicar en el archivo \texttt{.html} del rectángulo naranja que le es contiguo. Por ejemplo, el archivo \texttt{pas2A\_infoBenvinguda.html} de este proyecto es una réplica de la página especificada en el paréntesis \texttt{netflix.com/signup/registration} y el usuario llegará a ella a través del proceso de registro gracias a la aplicación de una lógica de back-end similar a la que usa Netflix.
		\end{enumerate}

		
	

		\section{Diagrama enrutamiento mercApp}
		\label{sec:anexo_diagramaEnrutamietnoMercApp}

		
		
	% Bibliografía (\chapter(6. Bibliograifa) como implicito)
	\addcontentsline{toc}{chapter}{7. Bibliografía} 
	\bibliographystyle{plain}  % Estilo de bibliografía
	\bibliography{referencias} % Nombre del archivo .bib  extensión
	
		
	

	\endgroup
\end{document}
